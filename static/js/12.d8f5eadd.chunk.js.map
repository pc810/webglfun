{"version":3,"sources":["shaders/grid/fragment.js","shaders/grid/vertex.js","components/Grid.js","overlays/Shaders.js"],"names":["fragmentShader","vertexShader","ConcentricCircleMesh","sides","material","THREE","extensions","derivatives","side","uniforms","resolution","type","value","useFrame","args","ConcentricCircle","inspiration","useState","count","data","setData","useEffect","document","title","gl","antialias","alpha","camera","position","near","far","onCreated","setClearColor","intensity","className","href","Shaders","vertex","fragment","styles","bottom","right","onUpdate","newData","path","label","min","max","step","display","setDisplay","shader","setShader","setType","handleClick","e","style","undefined","top","onClick"],"mappings":"wKAAaA,EAAc,ioBCAdC,EAAY,4O,cCUzB,SAASC,EAAT,GAAwC,IAATC,EAAQ,EAARA,MACvBC,EAAW,IAAIC,iBAAqB,CACxCC,WAAY,CACVC,YAAa,mDAEfC,KAAMH,aACNJ,eACAD,iBACAS,SAAU,CACRC,WAAY,CAAEC,KAAM,KAAMC,MAAO,IAAIP,WACrCF,MAAO,CACLQ,KAAM,IACNC,MAAO,MAOb,OAHAC,aAAS,WACPT,EAASK,SAASN,MAAMS,MAAQT,KAGhC,sBAAMC,SAAUA,EAAhB,SACE,qCAAqBU,KAAM,CAAC,EAAG,EAAG,OA0CzBC,UAtCf,YAA4C,IAAhBC,EAAe,EAAfA,YAAe,EACjBC,mBAAS,CAAEC,MAAO,IADD,mBAClCC,EADkC,KAC5BC,EAD4B,KAWzC,OANAC,qBAAU,WAER,OADAC,SAASC,MAAQ,mBACV,WACLD,SAASC,MAAQ,cAElB,IAED,qCACE,eAAC,IAAD,CACEC,GAAI,CAAEC,WAAW,EAAOC,OAAO,GAC/BC,OAAQ,CAAEC,SAAU,CAAC,EAAG,EAAG,GAAIC,KAAM,KAAOC,IAAK,KACjDC,UAAW,qBAAGP,GAAYQ,cAAc,UAH1C,UAKE,iCACA,4BAAYJ,SAAU,CAAC,IAAK,IAAK,KAAMK,UAAW,MAClD,cAAC,WAAD,UACE,cAAC/B,EAAD,CAAsBC,MAAOgB,EAAKD,UAEpC,cAAC,IAAD,OAGJF,GACA,sBAAKkB,UAAU,cAAf,2BAA2C,mBAAGC,KAAMnB,EAAT,qBAf3C,SAgBK,cAACoB,EAAA,EAAD,CAASC,OAAQpC,EAAcqC,SAAUtC,EAAgBuC,OAAQ,CAACC,OAAO,EAAEC,MAAM,KACpF,qBAAKP,UAAU,MAAf,SACA,cAAC,IAAD,CAAQf,KAAMA,EAAMuB,SA5BH,SAACC,GACpBvB,EAAQ,CAAEF,MAAOyB,EAAQzB,SA2BvB,SACE,cAAC,IAAD,CAAW0B,KAAK,QAAQC,MAAM,SAASC,IAAK,EAAGC,IAAK,GAAIC,KAAM,a,0DC9BvDZ,IAlCf,YAA+C,IAA5BC,EAA2B,EAA3BA,OAAQC,EAAmB,EAAnBA,SAASC,EAAU,EAAVA,OAAU,EAEdtB,mBAAS,QAFK,mBAErCgC,EAFqC,KAE5BC,EAF4B,OAGhBjC,mBAASqB,GAHO,mBAGrCa,EAHqC,KAG7BC,EAH6B,OAIpBnC,mBAAS,IAJW,mBAIrCN,EAJqC,KAI/B0C,EAJ+B,KAKtCC,EAAc,SAACC,GACAH,EAAb,aAANG,EAA6BjB,EAAsBD,GAChCgB,EAAb,aAANE,EAA2B,WAAsB,UACjDL,EAAW,UAKb,OACE,qCACE,sBAAKhB,UAAU,kBAAmBsB,WAAgBC,IAATlB,EAAmB,CAACmB,IAAI,EAAEjB,MAAM,GAAGF,EAA5E,UACKD,GACC,wBAAQqB,QAAS,kBAAML,EAAY,aAAnC,sBAEDjB,GACC,wBAAQsB,QAAS,kBAAML,EAAY,WAAnC,uBAGN,sBAAKpB,UAAU,2BAA2BsB,MAAO,CAACP,QAAQA,GAA1D,UACE,qBAAKf,UAAU,QAAQyB,QAAS,WAbpCT,EAAW,SAaP,mBACA,sBAAKhB,UAAU,iBAAf,UACE,+BAAKvB,EAAL,aACA,8BAAMwC","file":"static/js/12.d8f5eadd.chunk.js","sourcesContent":["export const fragmentShader = `\r\nuniform float time;\r\nuniform float sides;\r\nuniform vec4 resolution;\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\nfloat pi = 3.141592653589793238;\r\n\r\nfloat circleshape(vec2 position, float radius, vec2 center){\r\n    float x = length(position-center);\r\n    float sg = sin(150.*(x) + 1.5*time)*0.2;\r\n    return step(0.1, sg) + step(-0.19,sg);\r\n}   \r\n\r\nvoid main(){\r\n    vec2 uv = vUv;\r\n    vec3 col = vec3(0.);\r\n    uv *= sides;  \r\n    vec2 gv = fract(uv)-.5;\r\n    gl_FragColor = vec4(uv,0., 1.0);    \r\n    if(gv.x>.48 ||gv.y>.48) \r\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n    else \r\n        gl_FragColor = vec4(col, 1.0);  \r\n}\r\n`;\r\n","export const vertexShader = `\r\nuniform float time;\r\nuniform float sides;\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\nfloat PI = 3.141592653589793238;\r\nvoid main(){    \r\n  vUv = uv;\r\n \tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}\r\n`;\r\n","import React, { Suspense,useState,useEffect } from \"react\";\r\nimport * as THREE from \"three\";\r\nimport { Canvas, useFrame } from \"react-three-fiber\";\r\nimport { OrbitControls } from \"@react-three/drei\";\r\nimport Shaders from \"../overlays/Shaders\";\r\nimport { fragmentShader } from \"../shaders/grid/fragment\";\r\nimport { vertexShader } from \"../shaders/grid/vertex\";\r\nimport DatGui, { DatNumber } from \"react-dat-gui\";\r\nimport 'react-dat-gui/dist/index.css';\r\n\r\nfunction ConcentricCircleMesh({sides}) {\r\n  const material = new THREE.ShaderMaterial({\r\n    extensions: {\r\n      derivatives: \"#extension GL_OES_standard_derivatives : enable\",\r\n    },\r\n    side: THREE.DoubleSide,\r\n    vertexShader,\r\n    fragmentShader,\r\n    uniforms: {\r\n      resolution: { type: \"v4\", value: new THREE.Vector4() },\r\n      sides: {\r\n        type: \"f\",\r\n        value: 5.0,\r\n      },\r\n    },\r\n  });  \r\n  useFrame(() => {    \r\n    material.uniforms.sides.value = sides;\r\n  });\r\n  return (\r\n    <mesh material={material}>\r\n      <planeBufferGeometry args={[3, 3, 3]} />\r\n    </mesh>\r\n  );\r\n}\r\nfunction ConcentricCircle({ inspiration }) {\r\n  const [data, setData] = useState({ count: 5.0 });\r\n  const handleUpdate = (newData) => {\r\n    setData({ count: newData.count });\r\n  };\r\n  useEffect(() => {\r\n    document.title = \"ConcentricCircle\"    \r\n    return ()=>{\r\n      document.title = \"WebGlfun\"\r\n    }\r\n  }, [])\r\n  return (\r\n    <>\r\n      <Canvas\r\n        gl={{ antialias: false, alpha: false }}\r\n        camera={{ position: [0, 0, 2], near: 0.001, far: 1000 }}\r\n        onCreated={({ gl }) => gl.setClearColor(\"white\")}\r\n      >\r\n        <ambientLight />\r\n        <pointLight position={[150, 150, 150]} intensity={0.55} />\r\n        <Suspense>\r\n          <ConcentricCircleMesh sides={data.count}/>\r\n        </Suspense>\r\n        <OrbitControls />\r\n      </Canvas>\r\n      {\r\n    inspiration &&\r\n    <div className=\"inspiration\">Inspired from <a href={inspiration}>post</a></div>\r\n  }      <Shaders vertex={vertexShader} fragment={fragmentShader} styles={{bottom:0,right:0}}/>\r\n      <div className=\"gui\">\r\n      <DatGui data={data} onUpdate={handleUpdate} >\r\n        <DatNumber path=\"count\" label=\"Sides \" min={5} max={15} step={1} />\r\n      </DatGui>      \r\n      </div>     \r\n    </>\r\n  );\r\n}\r\n\r\nexport default ConcentricCircle;\r\n","import React, { useState } from \"react\";\r\n\r\nfunction Shaders({ vertex, fragment,styles }) {\r\n  // const [open, setOpen] = useState(false);\r\n  const [display, setDisplay] = useState('none')\r\n  const [shader, setShader] = useState(fragment);\r\n  const [type, setType] = useState('');\r\n  const handleClick = (e) => {\r\n    e === \"fragment\" ? setShader(fragment) : setShader(vertex);\r\n    e === \"fragment\" ? setType('fragment') : setType('vertex');\r\n    setDisplay('block')\r\n  };\r\n  const handleClose = ()=>{\r\n    setDisplay('none')\r\n  }\r\n  return (\r\n    <>\r\n      <div className=\"shaders-section\"  style={styles===undefined?{top:0,right:0}:styles}>                \r\n          {fragment && (\r\n            <button onClick={() => handleClick(\"fragment\")}>fragment</button>\r\n          )}\r\n          {vertex && (\r\n            <button onClick={() => handleClick(\"vertex\")}>vertex</button>\r\n          )}          \r\n      </div>\r\n      <div className=\"shader-overlay-container\" style={{display:display}}>\r\n        <div className=\"close\" onClick={()=>handleClose()}>close</div>\r\n        <div className=\"shader-overlay\">\r\n          <h1>{type} shader</h1>\r\n          <pre>{shader}</pre>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Shaders;\r\n"],"sourceRoot":""}