{"version":3,"sources":["components/GradientFire.js","shaders/GradientFire/vertex.js","shaders/GradientFire/fragment.js"],"names":["GradientFireMesh","color","cartoon","noiseTexture","useLoader","TextureLoader","distortTexture","wrapS","THREE","wrapT","material","extensions","derivatives","side","transparent","vertexShader","fragmentShader","uniforms","time","value","redChannel","r","greenChannel","g","blueChannel","b","resolution","type","clock","useFrame","getElapsedTime","args","GradientFire","inspiration","useState","data","setData","setCartoon","decColor","setDecColor","useEffect","document","title","c","parseInt","substr","gl","antialias","alpha","camera","position","near","far","onCreated","setClearColor","intensity","fallback","className","onUpdate","newData","path","label","style","href"],"mappings":"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","file":"static/js/12.0beefc77.chunk.js","sourcesContent":["import React, { Suspense,useEffect,useState } from \"react\";\r\nimport * as THREE from \"three\";\r\nimport { Canvas, useFrame,useLoader } from \"react-three-fiber\";\r\nimport { vertexShader } from \"../shaders/GradientFire/vertex\";\r\nimport { fragmentShader } from \"../shaders/GradientFire/fragment\";\r\nimport { TextureLoader } from \"three/src/loaders/TextureLoader.js\";\r\nimport DatGui, { DatBoolean, DatColor } from \"react-dat-gui\";\r\nimport \"react-dat-gui/dist/index.css\";\r\nimport {OrbitControls} from '@react-three/drei'\r\nfunction GradientFireMesh({color,cartoon}) {        \r\n    const noiseTexture = useLoader(TextureLoader, \"images/GradientFire/fire.png\");            \r\n    const distortTexture = useLoader(TextureLoader, \"images/GradientFire/rainbowcloud.jpg\");  \r\n    noiseTexture.wrapS = THREE.RepeatWrapping;\r\n    noiseTexture.wrapT = THREE.RepeatWrapping;          \r\n    distortTexture.wrapS = THREE.RepeatWrapping;\r\n    distortTexture.wrapT = THREE.RepeatWrapping;          \r\n    const material = new THREE.ShaderMaterial({        \r\n        extensions: {\r\n          derivatives: \"#extension GL_OES_standard_derivatives : enable\",\r\n        },\r\n        side: THREE.DoubleSide,\r\n        transparent: true,\r\n        vertexShader:vertexShader,\r\n        fragmentShader:fragmentShader,\r\n        uniforms: {\r\n          time: {\r\n            value: 0.0,\r\n          },\r\n          redChannel:{value:color.r},\r\n          greenChannel:{value:color.g},\r\n          blueChannel:{value:color.b},\r\n          cartoon:{value:cartoon?1:-1},\r\n          resolution: { type: \"v4\", value: new THREE.Vector4() },\r\n          noiseTexture : {type:\"t\", value: noiseTexture},\r\n          distortTexture : {type:\"t\", value: distortTexture}\r\n        },\r\n      });\r\n      const clock = new THREE.Clock();\r\n      useFrame(() => {\r\n        let time = clock.getElapsedTime();\r\n        material.uniforms.time.value = time;\r\n      });\r\n      return (\r\n        <mesh material={material}>\r\n          <planeBufferGeometry args={[2.5,2.5,2.5]} />\r\n        </mesh>\r\n      );\r\n}\r\nfunction GradientFire({ inspiration }) {\r\n  const [data, setData] = useState({ color: '#f06b0b',cartoon: false });\r\n  const [cartoon, setCartoon] = useState(false);\r\n  const [decColor, setDecColor] = useState({r:1,g:1,b:1});\r\n  const handleUpdate = (newData) => {\r\n    setData({ color: newData.color,cartoon:newData.cartoon});    \r\n    let r = parseInt(newData.color.substr(1,2), 16)/255;\r\n    let g = parseInt(newData.color.substr(3,2), 16)/255;\r\n    let b = parseInt(newData.color.substr(5,2), 16)/255;    \r\n    setDecColor({r:r,g:g,b:b});\r\n    setCartoon(newData.cartoon);    \r\n  };\r\n  useEffect(() => {\r\n    document.title = \"GradientFire\"\r\n    let c = \"#f06b0b\";\r\n    let r = parseInt(c.substr(1,2), 16)/255;\r\n    let g = parseInt(c.substr(3,2), 16)/255;\r\n    let b = parseInt(c.substr(5,2), 16)/255;    \r\n    setDecColor({r:r,g:g,b:b});\r\n    return ()=>{\r\n      document.title = \"WebGlfun\"\r\n    }\r\n  }, [])\r\n  \r\n  return (\r\n    <>\r\n      <Canvas\r\n        gl={{ antialias: false, alpha: false }}\r\n        camera={{ position: [0, 0, -2], near: 0.001, far: 1000 }}\r\n        onCreated={({ gl }) => gl.setClearColor(\"black\")}\r\n      >\r\n        <ambientLight />\r\n        <pointLight position={[150, 150, 150]} intensity={0.55} />\r\n        <Suspense fallback={<group></group>}>\r\n          <GradientFireMesh color={decColor} cartoon={cartoon}/>\r\n        </Suspense>\r\n        <OrbitControls/>        \r\n      </Canvas>\r\n      <div className=\"gui\">\r\n        <DatGui data={data} onUpdate={handleUpdate}>\r\n          <DatColor  path=\"color\" label=\"color \"  />\r\n          <DatBoolean path='cartoon' label='cartoon' />\r\n        </DatGui>\r\n      </div>\r\n      {inspiration && (\r\n        <div className=\"inspiration\" style={{color:\"white\"}}>\r\n          Inspired from <a href={inspiration}>post</a>\r\n        </div>\r\n      )}\r\n      {/* <Shaders vertex={vertexShader} fragment={fragmentShader} /> */}\r\n    </>\r\n  );\r\n}\r\nexport default GradientFire;\r\n","// export const vertexShader = `\r\n// uniform float time;\r\n// varying vec2 vUv;\r\n// varying vec3 vPosition;\r\n// float PI = 3.141592653589793238;\r\n// void main(){    \r\n//   vUv = uv;\r\n  \r\n//   vec3 pos = position;  \r\n//  \tgl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n// }\r\n// `;\r\nexport const vertexShader = `\r\nuniform float time;\r\nuniform float cartoon;\r\nvarying vec2 vUv;\r\nvarying vec2 vUv_a;\r\nvarying vec3 vPosition;\r\nfloat PI = 3.141592653589793238;\r\nvoid main(){\r\n  vUv = uv;\r\n  vUv_a = uv;\r\n  vUv_a.y -= fract(time*0.08);\r\n  vUv_a.x -= fract(time*.02);  \r\n  vec3 pos = position;  \r\n \tgl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n}\r\n`;\r\n","// export const fragmentShader = `\r\n// uniform float time;\r\n// uniform float redChannel;\r\n// uniform float blueChannel;\r\n// uniform float greenChannel;\r\n// uniform sampler2D noiseTexture;\r\n// uniform vec4 resolution;\r\n// varying vec2 vUv;\r\n// varying vec3 vPosition;\r\n// float PI = 3.141592653589793238;\r\n// //\tClassic Perlin 3D Noise \r\n// //\tby Stefan Gustavson\r\n// //\r\n// vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\r\n// vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\r\n// vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\r\n\r\n// float cnoise(vec3 P){\r\n//   vec3 Pi0 = floor(P); // Integer part for indexing\r\n//   vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\r\n//   Pi0 = mod(Pi0, 289.0);\r\n//   Pi1 = mod(Pi1, 289.0);\r\n//   vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n//   vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n//   vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n//   vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n//   vec4 iz0 = Pi0.zzzz;\r\n//   vec4 iz1 = Pi1.zzzz;\r\n\r\n//   vec4 ixy = permute(permute(ix) + iy);\r\n//   vec4 ixy0 = permute(ixy + iz0);\r\n//   vec4 ixy1 = permute(ixy + iz1);\r\n\r\n//   vec4 gx0 = ixy0 / 7.0;\r\n//   vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\r\n//   gx0 = fract(gx0);\r\n//   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n//   vec4 sz0 = step(gz0, vec4(0.0));\r\n//   gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n//   gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n//   vec4 gx1 = ixy1 / 7.0;\r\n//   vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\r\n//   gx1 = fract(gx1);\r\n//   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n//   vec4 sz1 = step(gz1, vec4(0.0));\r\n//   gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n//   gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n//   vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n//   vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n//   vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n//   vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n//   vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n//   vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n//   vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n//   vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n//   vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n//   g000 *= norm0.x;\r\n//   g010 *= norm0.y;\r\n//   g100 *= norm0.z;\r\n//   g110 *= norm0.w;\r\n//   vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n//   g001 *= norm1.x;\r\n//   g011 *= norm1.y;\r\n//   g101 *= norm1.z;\r\n//   g111 *= norm1.w;\r\n\r\n//   float n000 = dot(g000, Pf0);\r\n//   float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n//   float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n//   float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n//   float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n//   float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n//   float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n//   float n111 = dot(g111, Pf1);\r\n\r\n//   vec3 fade_xyz = fade(Pf0);\r\n//   vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n//   vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n//   float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \r\n//   return 2.2 * n_xyz;\r\n// }\r\n// void main(){        \r\n//     vec2  v_uv = vUv;            \r\n//     float offx = v_uv.x ;\r\n//     float offy = v_uv.y - time * 0.1 + sin(time * .001) * 3.;\r\n//     offx *= 6.;\r\n//     offy *= 10.;\r\n//     float n = cnoise(vec3(offx,offy,1.));    \r\n//     vec2 color = vec2(n);\r\n//     //float grad = smoothstep(.6,0.0,v_uv.y) + 6.*smoothstep(.8,0.0,v_uv.y);\r\n//     float grad = 12.*smoothstep(1.,0.0,v_uv.y);\r\n//     //vec4 img = texture2D(noiseTexture, 1.*v_uv + 0.5*color);\r\n//     vec4 img = texture2D(noiseTexture, v_uv + .2*color);\r\n//     vec4 mask =  grad*img;\r\n//     vec4 flamecolor = vec4(redChannel,greenChannel,blueChannel,0.);\r\n//     vec4 red = vec4(1.,1.,1.,1.) - flamecolor ;\r\n//     gl_FragColor = mix(mask,0.2 - red,.8);\r\n// }\r\n// `;\r\n\r\nexport const fragmentShader = `\r\nuniform float time;\r\nuniform float cartoon;\r\nuniform float redChannel;\r\nuniform float greenChannel;\r\nuniform float blueChannel;\r\nuniform sampler2D noiseTexture;\r\nuniform sampler2D distortTexture;\r\nuniform vec4 resolution;\r\nvarying vec2 vUv;\r\nvarying vec2 vUv_a;\r\nvarying vec3 vPosition;\r\nfloat PI = 3.141592653589793238;\r\n\r\nvoid main(){        \r\n    vec2  v_uv = vUv;           \r\n    vec2 v_uv_a = vUv_a;    \r\n    float gradientY = mix(2.,0., vUv.y + 0.5);\r\n    vec4 dist = texture2D(distortTexture,v_uv) * 0.5;\r\n    //vec4 noiseXT = texture2D(noiseTexture,v_uv.xy);\r\n    //vec4 noiseT = texture2D(noiseTexture,v_uv_a.xy + noiseXT.rb);\r\n    vec4 noiseT = texture2D(noiseTexture,v_uv_a.xy + dist.rg);    \r\n    vec4 grad = vec4(vec3(gradientY),1.);    \r\n    vec4 flamecolor =  vec4(1.,1.,1.,1.);\r\n    vec3 color = vec3(redChannel,greenChannel,blueChannel);\r\n    vec4 flame = flamecolor*((noiseT + grad));    \r\n    //orignal\r\n    gl_FragColor = flame*vec4(color,1.); \r\n    if(cartoon<0.0)\r\n        return;    \r\n    float c1 = step(0.35,flame.r);\r\n    float c2 = step(0.5,flame.g);\r\n    //gl_FragColor = vec4(vec3(c1),1.);\r\n    //gl_FragColor = vec4(vec3(c2),1.);\r\n    float mask_btw = c1 - c2;\r\n    float mask_bottom = c2;    \r\n    vec3 outputChannel = 1. - color;\r\n    outputChannel *= mask_btw;\r\n    outputChannel += mask_bottom*(color);\r\n    gl_FragColor = vec4(outputChannel,1.);\r\n}\r\n`;\r\n"],"sourceRoot":""}