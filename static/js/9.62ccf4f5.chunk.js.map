{"version":3,"sources":["components/DwlSphere.js","shaders/DwlSphere/sphereVertex.js","shaders/DwlSphere/sphereFragment.js","shaders/DwlSphere/gridVertex.js","shaders/DwlSphere/gridFragment.js"],"names":["DwlSphereMesh","materialSphere","THREE","extensions","derivatives","side","vertexShader","fragmentShader","transparent","uniforms","time","value","resolution","type","pos","materialGrid","clock","useFrame","getElapsedTime","material","rotation","Math","PI","args","position","DwlSphere","inspiration","useEffect","document","title","gl","antialias","alpha","camera","near","far","onCreated","setClearColor","intensity","className","style","color","href"],"mappings":"+IAQA,SAASA,IACP,IAAMC,EAAiB,IAAIC,iBAAqB,CAC9CC,WAAY,CACVC,YAAa,mDAEfC,KAAMH,aACNI,aCd2B,2ODe3BC,eEf6B,kTFgB7BC,aAAa,EACbC,SAAU,CACRC,KAAM,CACJC,MAAO,GAETC,WAAY,CAAEC,KAAM,KAAMF,MAAO,IAAIT,cAGnCY,EAAM,IAAIZ,UAAc,EAAE,GAAG,GAC7Ba,EAAe,IAAIb,iBAAqB,CAC5CC,WAAY,CACVC,YAAa,mDAEfC,KAAMH,aACNO,SAAU,CACRC,KAAM,CAAEG,KAAM,IAAKF,MAAO,GAC1BC,WAAY,CAAEC,KAAM,KAAMF,MAAO,IAAIT,YAEvCM,aAAa,EACbF,aGnCyB,obHoCzBC,eIpC2B,0XJsCvBS,EAAQ,IAAId,QAMlB,OALAe,aAAS,WACP,IAAIP,EAAOM,EAAME,iBACjBjB,EAAeQ,SAASC,KAAKC,MAAQD,EACrCK,EAAaN,SAASC,KAAKC,MAAQD,KAGnC,kCACE,sBAAMS,SAAUlB,EAAgBmB,SAAU,IAAIlB,QAAkBmB,KAAKC,GAAK,IAAhB,GAAqB,EAAE,EAAE,OAAnF,SACE,sCAAsBC,KAAM,CAAC,GAAK,IAAK,SAEzC,sBAAMJ,SAAUJ,EAAcS,SAAUV,EAAxC,SACE,qCAAqBS,KAAM,CAAC,GAAI,GAAI,GAAI,WAkCjCE,UA7Bf,YAAqC,IAAhBC,EAAe,EAAfA,YAOnB,OANAC,qBAAU,WAER,OADAC,SAASC,MAAQ,YACV,WACLD,SAASC,MAAQ,cAElB,IAED,qCACE,eAAC,IAAD,CACEC,GAAI,CAAEC,WAAW,EAAOC,OAAO,GAC/BC,OAAQ,CAAET,SAAU,CAAC,EAAG,EAAG,KAAMU,KAAM,KAAOC,IAAK,KACnDC,UAAW,qBAAGN,GAAYO,cAAc,UAH1C,UAKE,iCACA,4BAAYb,SAAU,CAAC,IAAK,IAAK,KAAMc,UAAW,MAClD,cAAC,WAAD,UACE,cAACtC,EAAD,SAGH0B,GACC,sBAAKa,UAAU,cAAcC,MAAO,CAACC,MAAM,SAA3C,2BACgB,mBAAGC,KAAMhB,EAAT","file":"static/js/9.62ccf4f5.chunk.js","sourcesContent":["import React, { Suspense,useEffect } from \"react\";\r\nimport * as THREE from \"three\";\r\nimport { Canvas, useFrame } from \"react-three-fiber\";\r\nimport { gridFragmentShader } from \"../shaders/DwlSphere/gridFragment\";\r\nimport { gridVertexShader } from \"../shaders/DwlSphere/gridVertex\";\r\nimport { sphereFragmentShader } from \"../shaders/DwlSphere/sphereFragment\";\r\nimport { sphereVertexShader } from \"../shaders/DwlSphere/sphereVertex\";\r\n\r\nfunction DwlSphereMesh() {    \r\n  const materialSphere = new THREE.ShaderMaterial({\r\n    extensions: {\r\n      derivatives: \"#extension GL_OES_standard_derivatives : enable\",\r\n    },\r\n    side: THREE.DoubleSide,\r\n    vertexShader: sphereVertexShader,\r\n    fragmentShader: sphereFragmentShader,\r\n    transparent: true,\r\n    uniforms: {\r\n      time: {\r\n        value: 0.0,\r\n      },\r\n      resolution: { type: \"v4\", value: new THREE.Vector4() },\r\n    },\r\n  });  \r\n  const pos = new THREE.Vector3(0,0,-2);\r\n  const materialGrid = new THREE.ShaderMaterial({\r\n    extensions: {\r\n      derivatives: \"#extension GL_OES_standard_derivatives : enable\",\r\n    },\r\n    side: THREE.DoubleSide,\r\n    uniforms: {\r\n      time: { type: \"f\", value: 0 },\r\n      resolution: { type: \"v4\", value: new THREE.Vector4() },\r\n    },\r\n    transparent: true,\r\n    vertexShader: gridVertexShader,\r\n    fragmentShader: gridFragmentShader,\r\n  });\r\n  const clock = new THREE.Clock();\r\n  useFrame(() => {\r\n    let time = clock.getElapsedTime();    \r\n    materialSphere.uniforms.time.value = time;\r\n    materialGrid.uniforms.time.value = time;\r\n  });\r\n  return (\r\n    <group>\r\n      <mesh material={materialSphere} rotation={new THREE.Euler(40 * (Math.PI / 180),0,0,'XYZ')}>\r\n        <sphereBufferGeometry args={[0.5, 100, 100]}/>\r\n      </mesh>\r\n      <mesh material={materialGrid} position={pos}>\r\n        <planeBufferGeometry args={[20, 20, 20, 20]} />\r\n      </mesh>\r\n    </group>\r\n  );\r\n}\r\nfunction DwlSphere({ inspiration }) {\r\n  useEffect(() => {\r\n    document.title = \"DwlSphere\"    \r\n    return ()=>{\r\n      document.title = \"WebGlfun\"\r\n    }\r\n  }, [])\r\n  return (\r\n    <>\r\n      <Canvas\r\n        gl={{ antialias: false, alpha: false }}\r\n        camera={{ position: [0, 0, 1.5], near: 0.001, far: 1000 }}\r\n        onCreated={({ gl }) => gl.setClearColor(\"black\")}\r\n      >\r\n        <ambientLight />\r\n        <pointLight position={[150, 150, 150]} intensity={0.55} />\r\n        <Suspense>\r\n          <DwlSphereMesh />\r\n        </Suspense>        \r\n      </Canvas>\r\n      {inspiration && (\r\n        <div className=\"inspiration\" style={{color:\"white\"}}>\r\n          Inspired from <a href={inspiration}>post</a>\r\n        </div>\r\n      )}\r\n      {/* <Shaders vertex={vertexShader} fragment={fragmentShader} /> */}\r\n    </>\r\n  );\r\n}\r\nexport default DwlSphere;\r\n","export const sphereVertexShader = `\r\nuniform float time;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\nfloat PI = 3.141592653589793238;\r\nvoid main(){  \r\n  vUv = uv;\r\n  vec3 pos = position;  \r\n \tgl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n}\r\n`;","export const sphereFragmentShader = `\r\nuniform float time;\r\nuniform vec4 resolution;\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\nvoid main(){      \r\n  vec2 newUv = (vUv - vec2(0.5))*resolution.zw  + vec2(0.5);      \r\n  float g = sin(121.*newUv.y + time)-0.5;\r\n  float c = smoothstep(.01, .09, g);\r\n  gl_FragColor = vec4(c,c,c, 1.0);  \r\n}\r\n`;","export const gridVertexShader = `\r\nuniform float time;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\n\r\nfloat PI = 3.141592653589793238;\r\n\r\nvoid main(){  \r\n  vUv = uv;\r\n  vec3 pos = position; \r\n  pos.z = 0.1*sin(.5*pos.y + time / 4.); \r\n  vec4 mvposition =  modelViewMatrix * vec4(pos, 1.0);\r\n  gl_PointSize = 800. * (1. / -mvposition.z);\r\n \tgl_Position = projectionMatrix * mvposition;\r\n \t// gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n}\r\n`;","export const gridFragmentShader = `\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\nfloat pi = 3.141592653589793238;\r\n\r\nvoid main(){          \r\n  vec2 newUv =vUv;\r\n  vec3 col = vec3(0.);\r\n  newUv *= 20.;  \r\n  vec2 gv = fract(newUv)-.5;\r\n  gl_FragColor = vec4(vUv,0., 1.0);    \r\n  if(gv.x>.49 ||gv.y>.49) \r\n    gl_FragColor = vec4(0.2549, 0.2549, 0.2549, 1.0);\r\n  else \r\n    gl_FragColor = vec4(col, 1.0);  \r\n}\r\n`;"],"sourceRoot":""}