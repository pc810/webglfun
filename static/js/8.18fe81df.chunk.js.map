{"version":3,"sources":["components/ImageParticle.js","shaders/ImageParticle/vertex.js","shaders/ImageParticle/fragment.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js"],"names":["ImageParticleMesh","stoneTexture","useLoader","TextureLoader","imgTexture","particleTexture","pointCount","useMemo","positions","coordinates","i","j","push","Float32Array","material","THREE","extensions","derivatives","side","transparent","vertexShader","fragmentShader","uniforms","time","value","type","resolution","depthTest","depthWrite","clock","useFrame","getElapsedTime","attach","attachObject","count","length","array","itemSize","Camera","props","ref","useRef","setDefaultCamera","useThree","useEffect","current","updateMatrixWorld","ImageParticle","inspiration","document","title","gl","antialias","alpha","onCreated","setClearColor","position","near","far","intensity","fallback","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","apply","_objectSpread2","target","arguments","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty"],"mappings":"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","file":"static/js/8.18fe81df.chunk.js","sourcesContent":["import React, { Suspense,useEffect,useMemo,useRef } from \"react\";\r\nimport * as THREE from \"three\";\r\nimport { Canvas, useFrame,useLoader,useThree } from \"react-three-fiber\";\r\nimport { vertexShader } from \"../shaders/ImageParticle/vertex\";\r\nimport { fragmentShader } from \"../shaders/ImageParticle/fragment\";\r\nimport { TextureLoader } from \"three/src/loaders/TextureLoader.js\";\r\n// import DatGui, { DatBoolean, DatColor } from \"react-dat-gui\";\r\nimport \"react-dat-gui/dist/index.css\";\r\nimport {OrbitControls} from '@react-three/drei'\r\nfunction ImageParticleMesh() {        \r\n    const stoneTexture = useLoader(TextureLoader, \"images/AnimeWater/stones.jpg\");  \r\n    const imgTexture = useLoader(TextureLoader, \"images/GradientFire/rainbowcloud.jpg\");  \r\n    const particleTexture = useLoader(TextureLoader, \"images/ImageParticle/particleshape.png\");  \r\n    // stoneTexture.wrapS = THREE.RepeatWrapping;\r\n    // stoneTexture.wrapT = THREE.RepeatWrapping;   \r\n    const pointCount = 256;\r\n    const [positions,coordinates] = useMemo(() => {\r\n        let positions = [];\r\n        let coordinates = [];\r\n        for (let i = -pointCount/2; i < pointCount/2; i++) \r\n          for (let j = -pointCount/2; j < pointCount/2; j++){\r\n          positions.push(i);\r\n          positions.push(j);\r\n          positions.push(0);          \r\n          coordinates.push((-i+pointCount/2)/pointCount);\r\n          coordinates.push((j+pointCount/2)/pointCount);          \r\n          coordinates.push(0);\r\n        }\r\n        return [new Float32Array(positions), new Float32Array(coordinates) ];\r\n      }, [pointCount]);               \r\n    const material = new THREE.ShaderMaterial({        \r\n        extensions: {\r\n          derivatives: \"#extension GL_OES_standard_derivatives : enable\",\r\n        },\r\n        side: THREE.DoubleSide,\r\n        transparent: true,\r\n        vertexShader:vertexShader,\r\n        fragmentShader:fragmentShader,       \r\n        uniforms: {\r\n          time: {\r\n            value: 0.0,\r\n          },\r\n          stoneTexture: {type:\"v4\", value :stoneTexture},\r\n          imgTexture: {type:\"v4\", value :imgTexture},\r\n          particleTexture: {type:\"v4\", value :particleTexture},\r\n          resolution: { type: \"v4\", value: new THREE.Vector4() },          \r\n        },\r\n        depthTest: false,\r\n        depthWrite: false,\r\n      });\r\n      const clock = new THREE.Clock();\r\n      useFrame(() => {\r\n        let time = clock.getElapsedTime();\r\n        material.uniforms.time.value = time;\r\n      });\r\n      return (\r\n        <points material={material}>\r\n        <bufferGeometry attach=\"geometry\">\r\n          <bufferAttribute\r\n            attachObject={[\"attributes\", \"position\"]}\r\n            count={positions.length / 3}\r\n            array={positions}\r\n            itemSize={3}\r\n          />\r\n          <bufferAttribute\r\n            attachObject={[\"attributes\", \"aCoordinates\"]}\r\n            count={positions.length / 3}\r\n            array={coordinates}\r\n            itemSize={3}\r\n          />\r\n        </bufferGeometry>\r\n      </points>\r\n      );\r\n}\r\nfunction Camera(props) {\r\n    const ref = useRef()\r\n    const { setDefaultCamera } = useThree()\r\n    // Make the camera known to the system\r\n    useEffect(() => void setDefaultCamera(ref.current), [setDefaultCamera])\r\n    // Update it every frame\r\n    useFrame(() => ref.current.updateMatrixWorld())\r\n    return <perspectiveCamera ref={ref} {...props} />\r\n  }\r\nfunction ImageParticle({ inspiration }) {  \r\n  useEffect(() => {\r\n    document.title = \"Image Particles\"\r\n    return ()=>{\r\n      document.title = \"WebGlfun\"\r\n    }\r\n  }, [])  \r\n  return (\r\n    <>\r\n      <Canvas\r\n        gl={{ antialias: false, alpha: false }}\r\n        // camera={{ position: [0, 0, -200], near: 0.001, far: 10000 }}\r\n        onCreated={({ gl }) => gl.setClearColor(\"black\")}\r\n      >\r\n        <Camera position={[0, 0, -300]} near={0.001} far={10000 }/>\r\n        <ambientLight />\r\n        <pointLight position={[150, 150, 150]} intensity={0.55} />\r\n        <Suspense fallback={<group></group>}>\r\n          <ImageParticleMesh />\r\n        </Suspense>\r\n        <OrbitControls/>        \r\n      </Canvas>\r\n      {/* {inspiration && (\r\n        <div className=\"inspiration\" style={{color:\"white\"}}>\r\n          Inspired from <a href={inspiration}>post</a>\r\n        </div>\r\n      )} */}\r\n      {/* <Shaders vertex={vertexShader} fragment={fragmentShader} /> */}\r\n    </>\r\n  );\r\n}\r\nexport default ImageParticle;\r\n","export const vertexShader = `\r\nuniform float time;\r\nuniform sampler2D stoneTexture;\r\nuniform sampler2D particleTexture;\r\nattribute vec3 aCoordinates;\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\nvarying float funct;\r\nvarying vec2 vCoordinate;\r\nfloat PI = 3.141592653589793238;\r\nfloat rand(vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nvoid main(){\r\n  vUv = uv;  \r\n  vCoordinate = aCoordinates.xy;\r\n  vec2 tcoord = aCoordinates.xy;\r\n  tcoord -= vec2(0.5);\r\n  vec3 pos = position;  \r\n  float rnd = rand(vec2(pos.x,pos.y));  \r\n  //float r = 10.*rand(aCoordinates.xy);\r\n  //pos.z = position.z + r*sin(time);\r\n  float r =100.*length(tcoord); \r\n  funct = tan(r*.01 + time) + sin(r*0.001 + time);\r\n  pos.z = 10.*funct;\r\n  vec4 mvposition =  modelViewMatrix * vec4(pos, 1.0);\r\n  gl_PointSize = 1000. * (1. / -mvposition.z);\r\n  gl_Position = projectionMatrix * mvposition;  \r\n}\r\n`;\r\n","export const fragmentShader = `\r\nuniform float time;\r\nuniform sampler2D stoneTexture;\r\nuniform sampler2D imgTexture;\r\nuniform sampler2D particleTexture;\r\nuniform vec4 resolution;\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\nvarying vec2 vCoordinate;\r\nvarying float funct;\r\nfloat PI = 3.141592653589793238;\r\n\r\nvoid main(){    \r\n    vec2 v_uv = vUv;    \r\n    vec2 v_uv_img = vCoordinate;\r\n    vec4 stone = texture2D(stoneTexture,v_uv_img);       \r\n    vec4 img2 = texture2D(imgTexture,v_uv_img);       \r\n    vec4 particle = texture2D(particleTexture,gl_PointCoord);\r\n    //float r =100.*length(tcoord); \r\n    //float f = tan(r*.01 + time) + sin(r*0.001 + time);\r\n    particle.r = smoothstep(0.1,0.4,particle.r);\r\n    gl_FragColor = stone;    \r\n    gl_FragColor.a *= particle.r; \r\n}\r\n`;\r\n","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}"],"sourceRoot":""}